rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // ── Users (/users/{userId}) ───────────────────────────────────────
    match /users/{userId} {
      allow read: if request.auth != null;

      allow create: if request.auth != null && request.auth.uid == userId
        && request.resource.data.id == userId
        && request.resource.data.displayName is string
        && request.resource.data.email is string
        && request.resource.data.createdAt is number;

      allow update: if request.auth != null && request.auth.uid == userId
        && request.resource.data.id == resource.data.id
        && request.resource.data.createdAt == resource.data.createdAt
        && request.resource.data.displayName is string
        && request.resource.data.email is string;
    }

    // ── Matches (/matches/{matchId}) ──────────────────────────────────
    match /matches/{matchId} {
      // Owner read
      allow read: if request.auth != null && request.auth.uid == resource.data.ownerId;

      // Owner create with field validation
      allow create: if request.auth != null
        && request.resource.data.ownerId == request.auth.uid
        && request.resource.data.visibility in ['private', 'shared', 'public']
        && request.resource.data.status in ['in-progress', 'completed', 'abandoned']
        && request.resource.data.config.gameType in ['singles', 'doubles']
        && request.resource.data.config.scoringMode in ['sideout', 'rally']
        && request.resource.data.config.matchFormat in ['single', 'best-of-3', 'best-of-5']
        && request.resource.data.config.pointsToWin in [11, 15, 21]
        && request.resource.data.team1Name is string
        && request.resource.data.team1Name.size() > 0
        && request.resource.data.team2Name is string
        && request.resource.data.team2Name.size() > 0
        && request.resource.data.sharedWith is list;

      // Owner update — ownerId is immutable
      allow update: if request.auth != null && request.auth.uid == resource.data.ownerId
        && request.resource.data.ownerId == resource.data.ownerId;

      // Owner delete
      allow delete: if request.auth != null && request.auth.uid == resource.data.ownerId;

      // Shared user read
      allow read: if request.auth != null && request.auth.uid in resource.data.sharedWith;

      // Shared user update only (NOT create/delete) — ownerId is immutable
      allow update: if request.auth != null && request.auth.uid in resource.data.sharedWith
        && request.resource.data.ownerId == resource.data.ownerId;

      // Public read (no auth required)
      allow read: if resource.data.visibility == 'public';

      // ── Score Events (/matches/{matchId}/scoreEvents/{eventId}) ───
      match /scoreEvents/{eventId} {
        function matchData() {
          return get(/databases/$(database)/documents/matches/$(matchId)).data;
        }
        function isMatchOwnerOrShared() {
          return request.auth != null && (
            matchData().ownerId == request.auth.uid ||
            request.auth.uid in matchData().sharedWith
          );
        }

        allow read: if isMatchOwnerOrShared()
          || matchData().visibility == 'public';

        allow create: if isMatchOwnerOrShared()
          && request.resource.data.matchId == matchId
          && request.resource.data.type in ['POINT_SCORED', 'SIDE_OUT', 'FAULT', 'UNDO']
          && request.resource.data.team in [1, 2]
          && request.resource.data.team1Score is number
          && request.resource.data.team1Score >= 0
          && request.resource.data.team2Score is number
          && request.resource.data.team2Score >= 0;

        allow update: if isMatchOwnerOrShared()
          && request.resource.data.matchId == resource.data.matchId;

        allow delete: if isMatchOwnerOrShared();
      }
    }

    // ── Tournaments (/tournaments/{tournamentId}) ─────────────────────
    match /tournaments/{tournamentId} {

      // Any authenticated user can read tournaments
      allow read: if request.auth != null;

      // Public tournaments can be read without authentication
      allow read: if resource.data.visibility == 'public';

      // Create with full field validation
      allow create: if request.auth != null
        && request.resource.data.organizerId == request.auth.uid
        && request.resource.data.name is string
        && request.resource.data.name.size() > 0
        && request.resource.data.name.size() <= 100
        && request.resource.data.status == 'setup'
        && request.resource.data.format in ['round-robin', 'single-elimination', 'pool-bracket']
        && request.resource.data.date is number
        && request.resource.data.location is string
        && request.resource.data.config is map
        && request.resource.data.config.gameType in ['singles', 'doubles']
        && request.resource.data.config.scoringMode in ['sideout', 'rally']
        && request.resource.data.config.matchFormat in ['single', 'best-of-3', 'best-of-5']
        && request.resource.data.config.pointsToWin in [11, 15, 21]
        && request.resource.data.scorekeeperIds is list
        && request.resource.data.visibility in ['private', 'public'];

      // Update: status transitions + field validation + organizerId immutable
      allow update: if request.auth != null && request.auth.uid == resource.data.organizerId
        && request.resource.data.organizerId == resource.data.organizerId
        && request.resource.data.name is string
        && request.resource.data.name.size() > 0
        && request.resource.data.name.size() <= 100
        && request.resource.data.date is number
        && request.resource.data.location is string
        && request.resource.data.format in ['round-robin', 'single-elimination', 'pool-bracket']
        && request.resource.data.config is map
        && request.resource.data.config.gameType in ['singles', 'doubles']
        && request.resource.data.scorekeeperIds is list
        && (
          // Valid status transitions
          (resource.data.status == 'setup' && request.resource.data.status in ['registration', 'cancelled']) ||
          (resource.data.status == 'registration' && request.resource.data.status in ['pool-play', 'bracket', 'cancelled']) ||
          (resource.data.status == 'pool-play' && request.resource.data.status in ['bracket', 'paused', 'completed', 'cancelled']) ||
          (resource.data.status == 'bracket' && request.resource.data.status in ['completed', 'paused', 'cancelled']) ||
          (resource.data.status == 'paused' && request.resource.data.status in ['pool-play', 'bracket', 'completed', 'cancelled']) ||
          // Allow updates that don't change status
          request.resource.data.status == resource.data.status
        );

      // Only the organizer can delete a tournament
      allow delete: if request.auth != null && request.auth.uid == resource.data.organizerId;

      // Helper: check tournament is in an active state (not completed/cancelled)
      function isTournamentActive() {
        let status = get(/databases/$(database)/documents/tournaments/$(tournamentId)).data.status;
        return status != 'completed' && status != 'cancelled';
      }

      // Helper: check if parent tournament is public
      function isTournamentPublic() {
        return get(/databases/$(database)/documents/tournaments/$(tournamentId)).data.visibility == 'public';
      }

      // ── Teams (/tournaments/{tid}/teams/{teamId}) ─────────────────
      match /teams/{teamId} {
        allow read: if request.auth != null;
        allow read: if isTournamentPublic();

        allow create: if request.auth != null
          && isTournamentActive()
          && get(/databases/$(database)/documents/tournaments/$(tournamentId)).data.organizerId == request.auth.uid
          && request.resource.data.tournamentId == tournamentId
          && request.resource.data.name is string
          && request.resource.data.name.size() > 0
          && request.resource.data.playerIds is list
          && request.resource.data.playerIds.size() > 0;

        allow update: if request.auth != null
          && isTournamentActive()
          && request.resource.data.tournamentId == resource.data.tournamentId
          && (get(/databases/$(database)/documents/tournaments/$(tournamentId)).data.organizerId == request.auth.uid
              || (request.auth.uid in get(/databases/$(database)/documents/tournaments/$(tournamentId)).data.scorekeeperIds
                  && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['seed', 'updatedAt'])));

        allow delete: if request.auth != null
          && get(/databases/$(database)/documents/tournaments/$(tournamentId)).data.organizerId == request.auth.uid;
      }

      // ── Pools (/tournaments/{tid}/pools/{poolId}) ─────────────────
      match /pools/{poolId} {
        allow read: if request.auth != null;
        allow read: if isTournamentPublic();

        allow create: if request.auth != null
          && isTournamentActive()
          && get(/databases/$(database)/documents/tournaments/$(tournamentId)).data.organizerId == request.auth.uid
          && request.resource.data.tournamentId == tournamentId
          && request.resource.data.name is string
          && request.resource.data.name.size() > 0
          && request.resource.data.teamIds is list;

        allow update: if request.auth != null
          && isTournamentActive()
          && get(/databases/$(database)/documents/tournaments/$(tournamentId)).data.organizerId == request.auth.uid
          && request.resource.data.tournamentId == resource.data.tournamentId;

        allow delete: if request.auth != null
          && get(/databases/$(database)/documents/tournaments/$(tournamentId)).data.organizerId == request.auth.uid;
      }

      // ── Bracket (/tournaments/{tid}/bracket/{slotId}) ─────────────
      match /bracket/{slotId} {
        allow read: if request.auth != null;
        allow read: if isTournamentPublic();

        allow create: if request.auth != null
          && isTournamentActive()
          && get(/databases/$(database)/documents/tournaments/$(tournamentId)).data.organizerId == request.auth.uid
          && request.resource.data.tournamentId == tournamentId
          && request.resource.data.round is number
          && request.resource.data.position is number;

        allow update: if request.auth != null
          && isTournamentActive()
          && request.resource.data.tournamentId == resource.data.tournamentId
          && (get(/databases/$(database)/documents/tournaments/$(tournamentId)).data.organizerId == request.auth.uid
              || (request.auth.uid in get(/databases/$(database)/documents/tournaments/$(tournamentId)).data.scorekeeperIds
                  && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['winnerId', 'matchId', 'updatedAt'])));

        allow delete: if request.auth != null
          && get(/databases/$(database)/documents/tournaments/$(tournamentId)).data.organizerId == request.auth.uid;
      }

      // ── Registrations (/tournaments/{tid}/registrations/{regId}) ──
      match /registrations/{regId} {
        allow read: if request.auth != null;
        allow read: if isTournamentPublic();

        // Players can register themselves — only during registration phase
        allow create: if request.auth != null
          && isTournamentActive()
          && request.resource.data.userId == request.auth.uid
          && request.resource.data.tournamentId == tournamentId
          && request.resource.data.paymentStatus == 'unpaid'
          && request.resource.data.paymentNote == ''
          && get(/databases/$(database)/documents/tournaments/$(tournamentId)).data.status == 'registration';

        // Organizer can add players on their behalf
        allow create: if request.auth != null
          && isTournamentActive()
          && get(/databases/$(database)/documents/tournaments/$(tournamentId)).data.organizerId == request.auth.uid
          && request.resource.data.tournamentId == tournamentId
          && request.resource.data.paymentStatus == 'unpaid'
          && request.resource.data.paymentNote == ''
          && get(/databases/$(database)/documents/tournaments/$(tournamentId)).data.status == 'registration';

        // Organizer can update any registration (e.g., payment status)
        allow update: if request.auth != null
          && get(/databases/$(database)/documents/tournaments/$(tournamentId)).data.organizerId == request.auth.uid
          && request.resource.data.paymentStatus in ['unpaid', 'paid', 'waived']
          && request.resource.data.userId == resource.data.userId
          && request.resource.data.tournamentId == resource.data.tournamentId;

        // Players can update their own registration, but NOT paymentStatus or paymentNote
        allow update: if request.auth != null && resource.data.userId == request.auth.uid
          && request.resource.data.paymentStatus == resource.data.paymentStatus
          && request.resource.data.paymentNote == resource.data.paymentNote
          && request.resource.data.userId == resource.data.userId
          && request.resource.data.tournamentId == resource.data.tournamentId;

        // Players can delete their own registration; organizer can delete any
        allow delete: if request.auth != null
          && (resource.data.userId == request.auth.uid
              || get(/databases/$(database)/documents/tournaments/$(tournamentId)).data.organizerId == request.auth.uid);
      }

      // ── Invitations (/tournaments/{tid}/invitations/{invId}) ──
      match /invitations/{invitationId} {
        // Organizer can read all invitations for their tournament
        allow read: if request.auth != null
          && get(/databases/$(database)/documents/tournaments/$(tournamentId)).data.organizerId == request.auth.uid;

        // Invited user can read their own invitation
        allow read: if request.auth != null
          && resource.data.invitedUserId == request.auth.uid;

        // Only organizer can create invitations
        allow create: if request.auth != null
          && get(/databases/$(database)/documents/tournaments/$(tournamentId)).data.organizerId == request.auth.uid
          && request.resource.data.tournamentId == tournamentId
          && request.resource.data.invitedUserId is string
          && request.resource.data.invitedEmail is string
          && request.resource.data.invitedName is string
          && request.resource.data.invitedByUserId == request.auth.uid
          && request.resource.data.status == 'pending';

        // Invited user can update status (accept/decline) only from pending
        allow update: if request.auth != null
          && resource.data.invitedUserId == request.auth.uid
          && request.resource.data.status in ['accepted', 'declined']
          && resource.data.status == 'pending'
          && request.resource.data.invitedUserId == resource.data.invitedUserId
          && request.resource.data.tournamentId == resource.data.tournamentId
          && request.resource.data.invitedByUserId == resource.data.invitedByUserId;
      }
    }

    // ── Collection Group: Invitations (for player inbox query) ────────
    match /{path=**}/invitations/{invitationId} {
      allow read: if request.auth != null
        && resource.data.invitedUserId == request.auth.uid;
    }

    // ── Buddy Groups (/buddyGroups/{groupId}) ─────────────────────────
    match /buddyGroups/{groupId} {

      // Any authenticated user can read group metadata (share-code invite links need this).
      // The members subcollection is separately protected.
      allow read: if request.auth != null;

      // Any authenticated user can create a group
      allow create: if request.auth != null
        && request.resource.data.createdBy == request.auth.uid
        && request.resource.data.name is string
        && request.resource.data.name.size() > 0
        && request.resource.data.name.size() <= 50
        && request.resource.data.memberCount == 0
        && request.resource.data.visibility in ['private', 'public'];

      // Creator or admin can update group (creator needed for atomic addMember batch)
      allow update: if request.auth != null
        && request.resource.data.createdBy == resource.data.createdBy
        && (request.auth.uid == resource.data.createdBy
            || (exists(/databases/$(database)/documents/buddyGroups/$(groupId)/members/$(request.auth.uid))
                && get(/databases/$(database)/documents/buddyGroups/$(groupId)/members/$(request.auth.uid)).data.role == 'admin'));

      // Only admin can delete
      allow delete: if request.auth != null
        && get(/databases/$(database)/documents/buddyGroups/$(groupId)/members/$(request.auth.uid)).data.role == 'admin';

      // ── Members (/buddyGroups/{gid}/members/{userId}) ──────────
      match /members/{userId} {
        // Any group member can read members list
        allow read: if request.auth != null
          && exists(/databases/$(database)/documents/buddyGroups/$(groupId)/members/$(request.auth.uid));

        // Admin can add anyone; user can add themselves
        allow create: if request.auth != null
          && (request.auth.uid == userId
              || get(/databases/$(database)/documents/buddyGroups/$(groupId)/members/$(request.auth.uid)).data.role == 'admin')
          && request.resource.data.userId == userId;

        // Admin can remove anyone; user can remove themselves
        allow delete: if request.auth != null
          && (request.auth.uid == userId
              || get(/databases/$(database)/documents/buddyGroups/$(groupId)/members/$(request.auth.uid)).data.role == 'admin');
      }
    }

    // ── Game Sessions (/gameSessions/{sessionId}) ────────────────────
    match /gameSessions/{sessionId} {

      // Open sessions are readable by anyone authenticated; group members can read group sessions
      allow read: if request.auth != null
        && (resource.data.visibility == 'open'
            || (resource.data.groupId != null
                && exists(/databases/$(database)/documents/buddyGroups/$(resource.data.groupId)/members/$(request.auth.uid))));

      // Any authenticated user can create (standalone or in their group)
      allow create: if request.auth != null
        && request.resource.data.createdBy == request.auth.uid
        && request.resource.data.status == 'proposed'
        && request.resource.data.spotsConfirmed == 0;

      // Creator can update any session field; RSVP participants can update spotsConfirmed
      allow update: if request.auth != null
        && request.resource.data.createdBy == resource.data.createdBy
        && (resource.data.createdBy == request.auth.uid
            || request.resource.data.diff(resource.data).affectedKeys().hasOnly(['spotsConfirmed', 'updatedAt']));

      // Creator can delete
      allow delete: if request.auth != null
        && resource.data.createdBy == request.auth.uid;

      // ── RSVPs (/gameSessions/{sid}/rsvps/{userId}) ─────────────
      match /rsvps/{userId} {
        // Anyone who can read session can read RSVPs
        allow read: if request.auth != null;

        // Users can create/update/delete their own RSVP
        allow create: if request.auth != null && request.auth.uid == userId
          && request.resource.data.userId == userId;
        allow update: if request.auth != null && request.auth.uid == userId;
        allow delete: if request.auth != null && request.auth.uid == userId;
      }
    }

    // ── Buddy Notifications (/users/{userId}/buddyNotifications/{nid}) ─
    match /users/{userId}/buddyNotifications/{notifId} {
      allow read: if request.auth != null && request.auth.uid == userId;
      allow create: if request.auth != null
        && request.resource.data.userId == userId
        && request.resource.data.type in ['session_proposed','session_confirmed','session_cancelled','spot_opened','player_joined','group_invite','voting_reminder']
        && request.resource.data.message is string
        && request.resource.data.read == false;
      allow update: if request.auth != null && request.auth.uid == userId;
      allow delete: if request.auth != null && request.auth.uid == userId;
    }

    // ── Collection Group: Members (for "my groups" query) ──────────────
    match /{path=**}/members/{userId} {
      allow read: if request.auth != null
        && resource.data.userId == request.auth.uid;
    }
  }
}
