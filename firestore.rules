rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Users can read/write their own profile
    match /users/{userId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }

    // Match rules
    match /matches/{matchId} {
      allow read, write: if request.auth != null && request.auth.uid == resource.data.ownerId;
      allow create: if request.auth != null && request.resource.data.ownerId == request.auth.uid;
      allow read, write: if request.auth != null && request.auth.uid in resource.data.sharedWith;
      allow read: if resource.data.visibility == 'public';

      match /scoreEvents/{eventId} {
        allow read, write: if request.auth != null && (
          get(/databases/$(database)/documents/matches/$(matchId)).data.ownerId == request.auth.uid ||
          request.auth.uid in get(/databases/$(database)/documents/matches/$(matchId)).data.sharedWith
        );
        allow read: if get(/databases/$(database)/documents/matches/$(matchId)).data.visibility == 'public';
      }
    }

    // Tournament rules
    match /tournaments/{tournamentId} {

      // Any authenticated user can read tournaments
      allow read: if request.auth != null;

      // C2: Field validation on tournament creation — name must be non-empty string
      // (max 100 chars), status must start as 'setup', format must be valid
      allow create: if request.auth != null
        && request.resource.data.organizerId == request.auth.uid
        && request.resource.data.name is string
        && request.resource.data.name.size() > 0
        && request.resource.data.name.size() <= 100
        && request.resource.data.status == 'setup'
        && request.resource.data.config.format in ['round-robin', 'single-elimination', 'pool-bracket'];

      // C3: Status transition validation for tournament updates
      // C9: organizerId is immutable — must match existing value
      allow update: if request.auth != null && request.auth.uid == resource.data.organizerId
        && request.resource.data.organizerId == resource.data.organizerId
        && (
          // Valid status transitions
          (resource.data.status == 'setup' && request.resource.data.status in ['registration', 'cancelled']) ||
          (resource.data.status == 'registration' && request.resource.data.status in ['pool-play', 'bracket', 'cancelled']) ||
          (resource.data.status == 'pool-play' && request.resource.data.status in ['bracket', 'paused', 'completed', 'cancelled']) ||
          (resource.data.status == 'bracket' && request.resource.data.status in ['completed', 'paused', 'cancelled']) ||
          (resource.data.status == 'paused' && request.resource.data.status in ['pool-play', 'bracket', 'cancelled']) ||
          // Allow updates that don't change status (e.g., updating config, adding scorekeepers)
          request.resource.data.status == resource.data.status
        );

      // Only the organizer can delete a tournament
      allow delete: if request.auth != null && request.auth.uid == resource.data.organizerId;

      // C5: Teams — organizer has full control, scorekeepers can only update
      match /teams/{teamId} {
        allow read: if request.auth != null;
        allow create, delete: if request.auth != null
          && get(/databases/$(database)/documents/tournaments/$(tournamentId)).data.organizerId == request.auth.uid;
        allow update: if request.auth != null
          && (get(/databases/$(database)/documents/tournaments/$(tournamentId)).data.organizerId == request.auth.uid
              || request.auth.uid in get(/databases/$(database)/documents/tournaments/$(tournamentId)).data.scorekeeperIds);
      }

      // Pools — only the organizer can manage pools
      match /pools/{poolId} {
        allow read: if request.auth != null;
        allow write: if request.auth != null &&
          get(/databases/$(database)/documents/tournaments/$(tournamentId)).data.organizerId == request.auth.uid;
      }

      // C5: Bracket — organizer has full control, scorekeepers can only update
      match /bracket/{slotId} {
        allow read: if request.auth != null;
        allow create, delete: if request.auth != null
          && get(/databases/$(database)/documents/tournaments/$(tournamentId)).data.organizerId == request.auth.uid;
        allow update: if request.auth != null
          && (get(/databases/$(database)/documents/tournaments/$(tournamentId)).data.organizerId == request.auth.uid
              || request.auth.uid in get(/databases/$(database)/documents/tournaments/$(tournamentId)).data.scorekeeperIds);
      }

      // C6: TODO — use userId as doc ID to prevent duplicate registrations.
      // This requires changing the registration save logic in the app layer.
      match /registrations/{regId} {
        allow read: if request.auth != null;

        // Players can register themselves
        allow create: if request.auth != null && request.resource.data.userId == request.auth.uid;

        // Organizer can update any registration (e.g., payment status)
        allow update: if request.auth != null &&
          get(/databases/$(database)/documents/tournaments/$(tournamentId)).data.organizerId == request.auth.uid;

        // C1: Players can update their own registration, but NOT paymentStatus or paymentNote
        allow update: if request.auth != null && resource.data.userId == request.auth.uid
          && request.resource.data.paymentStatus == resource.data.paymentStatus
          && request.resource.data.paymentNote == resource.data.paymentNote;

        // C8: Players can delete their own registration; organizer can delete any
        allow delete: if request.auth != null
          && (resource.data.userId == request.auth.uid
              || get(/databases/$(database)/documents/tournaments/$(tournamentId)).data.organizerId == request.auth.uid);
      }
    }
  }
}
